\documentclass{amsart}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{times}
\usepackage{xypic}

\newcommand{\NN}{\mathbb{N}} % natural numbers
\newcommand{\RR}{\mathbb{R}} % real numbers
\newcommand{\ZZ}{\mathbb{Z}} % integers

\newcommand{\theory}[1]{\mathsf{#1}} % A named theory
\newcommand{\signature}[1]{\Sigma_{\theory{#1}}} % The signature of a theory
\newcommand{\equations}[1]{\mathcal{E}_{\theory{#1}}} % Equations of a theory

\newcommand{\Mod}[1]{\text{\textbf{Mod}}(\theory{#1})} % Models of a theory in Set
\newcommand{\ModC}[2]{\text{\textbf{Mod}}_{\category{#1}}(\theory{#2})} % Models of a theory in a category
\newcommand{\ComodC}[2]{\text{\textbf{CoMod}}_{\category{#1}}(\theory{#2})} % Comodels of a theory in a category
\newcommand{\opcat}[1]{\ensuremath{#1^{\text{\textbf{op}}}}}
\newcommand{\from}{\leftarrow}

\newcommand{\category}[1]{\text{\textbf{#1}}} % A named category
\newcommand{\Set}{\category{Set}} % The category of sets

\newcommand{\Free}[2]{F_{\theory{#1}}(#2)} % free model

\newcommand{\all}[1]{\forall #1 \,.\,} % universal quantifier
\newcommand{\some}[1]{\exists #1 \,.\,} % existential quantifier
\newcommand{\set}[1]{\{#1\}} % set description
\newcommand{\such}{\mid}

\newcommand{\lam}[1]{\lambda #1 \,.\,}

\newcommand{\family}[2]{\{#1\}_{#2}} % a family

\newcommand{\finpow}[1]{\mathcal{P}_{{<}\omega}(#1)} % finite powerset

\newcommand{\Tree}[2]{\mathsf{Tree}_{#1}(#2)} % trees over a signature
\newcommand{\leaf}[1]{\mathsf{leaf}(#1)} % the embedding of generators into trees

\newcommand{\op}[1]{\mathsf{op}_{#1}} % an operation symbol
\newcommand{\arity}[1]{\mathsf{ar}_{#1}} % arity of a symbol

\newcommand{\one}{\mathsf{1}} % the terminal object

\newcommand{\Cinfty}{\mathcal{C}^\infty}

\newcommand{\sem}[1]{[\![#1]\!]} % semantic bracket

\newcommand{\bool}{\mathsf{bool}} % booleans
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\cond}[3]{\mathsf{if}\;#1\;\mathsf{then}\;#2\;\mathsf{else}\;#3}

%%% Macros for the programming language

% General syntactic constructs
\newcommand{\kode}[1]{\mathtt{#1}}

% Core syntax
\newcommand{\seq}[2]{\kode{do}\; #1 \leftarrow #2 \;\kode{in}\;}
\newcommand{\conditional}[3]{\kode{if}\; #1 \;\kode{then}\; #2 \;\kode{else}\; #3}
\newcommand{\fun}[1]{\kode{fun}\; #1 \mapsto}
\newcommand{\handler}{\kode{handler}\;}
\newcommand{\opgen}[1]{\op{#1}}
\newcommand{\opcall}[4]{#1(#2; #3.\,#4)}
\newcommand{\opclause}[3]{#1(#2; #3) \mapsto}
\newcommand{\return}[1]{\kode{return}\;#1}
\newcommand{\retclause}[1]{\return{#1} \mapsto}
\newcommand{\withhandle}[2]{\kode{with}\; #1\; \kode{handle}\; #2}



{\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}[definition]{Example}
}

\begin{document}

\title{What is coalgebraic about algebraic effects and handlers?}

\author{Matija Pretnar}

\maketitle

As the name suggests and as Andrej Bauer explained in his note \emph{``What is algebraic about algebraic effects and handlers?''} above, algebraic effects and their handlers have a strong connection with algebras. In this note, I will try to show that they also have some relatively unexplored coalgebraic features. We will continue where the previous note left off, so make sure to read that one first.


\section{Dualizing models of algebraic theories}
\label{sec:dualizing-models}

The main objects of our study will be \emph{comodels} of an algebraic theory. Let us start with an abstract categorical definition and work back from there to a useful characterization. Those not interested in categorical manipulations may skip to Section~\ref{sec:comodels} and take that as a starting point.

Recall that for a given category $\category{C}$, the dual category $\opcat{\category{C}}$ has the same objects as $\category{C}$, whereas its morphisms go in the other direction: morphisms between $A$ and $B$ in $\opcat{\category{C}}$ correspond exactly to morphisms $B \to A$ in $\category{C}$, which is why we will write them as $A \from B$, keeping objects in the same place and reversing the arrows. We use bold letters to write $\text{\textbf{op}}$, the standard notation for a dual category, in order to distinguish it from $\op{}$, the standard notation for an algebraic operation.

Take $\category{C}$ to be any category with finite \emph{coproducts}. We roughly follow Plotkin \& Power~\cite{power} and define the category of $\theory{T}$-comodels $\ComodC{C}{T}$ and $\theory{T}$-cohomomorphisms to be $\opcat{(\ModC{\opcat{C}}{T})}$, i.e. the dual of $\theory{T}$-models in the dual of $\category{C}$. Let us express these in more familiar terms.

First, consider the objects of $\ComodC{C}{T}$. Since a category has the same objects as its dual, these correspond to objects of $\ModC{\opcat{C}}{T}$, which are given by:
%
\begin{enumerate}
\item An object $|W|$ in $\opcat{\category{C}}$, called the \emph{carrier}. Again, a category has the same objects as its dual, these correspond to objects $|W|$ in $\category{C}$.
\item For each operation symbol $\op{i}$ a morphism in $\opcat{\category{C}}$
  %
  \begin{equation*}
    \sem{\op{i}}_W : \underbrace{|W| \times \cdots \times |W|}_{\arity{i}} \from |W|,
  \end{equation*}
  which validates all the equations of the theory (we will return to this in a moment). However, products in $\opcat{\category{C}}$ correspond to coproducts in $\category{C}$ (which is why we required $\category{C}$ to have finite coproducts), thus the above family of morphisms in $\opcat{\category{C}}$ corresponds to the family of morphisms
  %
    \begin{equation*}
    \sem{\op{i}}^W : |W| \to \underbrace{|W| + \cdots + |W|}_{\arity{i}},
  \end{equation*}
  in $\category{C}$, which we call \emph{cooperations}. We abbreviate an $n$-ary coproduct $|W| + \cdots + |W|$ by $n \cdot |W|$.
\end{enumerate}
Since the category $\ComodC{C}{T} = \opcat{(\ModC{\opcat{C}}{T})}$ has the same objects as its dual $\ModC{\opcat{C}}{T}$, such objects are exactly $\theory{T}$-comodels.

Next, we need to consider what it means for a family of cooperations on a model to respect the equations of the theory~$\theory{T}$. For this, we first need to determine how to extend the interpretation from operations to $\Sigma$-terms. A $\Sigma$-term in context
%
\begin{equation*}
  x_0, \ldots, x_{k-1} \mid t
\end{equation*}
%
is interpreted by a map
%
\begin{equation*}
  \sem{x_0, \ldots, x_{k-1} \mid t}^I : |I| \to k \cdot |I|,
\end{equation*}
%
as follows:
%
\begin{enumerate}
\item the variable $x_i$ is interpreted as the $i$-th injection,
  %
  \begin{equation*}
    \sem{x_0, \ldots, x_{k-1} \mid  x_i}^I = \iota_i : |I| \to k \cdot |I|,
  \end{equation*}
\item a compound term in context
  %
  \begin{equation*}
    x_0, \ldots, x_{k-1} \mid \op{i}(t_1, \ldots, t_{\arity{i}})
  \end{equation*}
  %
  is interpreted as the composition of maps
  %
  \begin{equation*}
    \xymatrix@+6em{
      {|I|} \ar[r]^{\sem{\op{i}}^I}
      &
      {{\arity{i}} \cdot |I|} \ar[r]^{[\sem{t_0}_I, \ldots, \sem{t_{\arity{i}}}_I]}
      &
      {k \cdot |I|}
    }
  \end{equation*}
\end{enumerate}
%
where for morphisms $f_i \colon A_i \to B$, we define the morphism $[f_1, \dots, f_k] \colon A_1 + \cdots + A_k \to B$ by $[f_1, \dots, f_k](\iota_j(x)) = f_j(x)$.
Then, a model $W$ validates the theory~$\theory{T}$, if for every equation
%
\begin{equation*}
  x_1, \ldots, x_k \mid \ell = r
\end{equation*}
%
in~$\equations{T}$, the maps
%
\begin{equation*}
  \sem{x_1, \ldots, x_k \mid \ell}^W : |W| \to k \cdot |W|
  \qquad\text{and}\qquad
  \sem{x_1, \ldots, x_k \mid r}^W : |W| \to k \cdot |W|
\end{equation*}
%
are equal.

Finally, morphisms between comodels $W$ and $V$ in $\ComodC{C}{T}$ are exactly $\theory{T}$-homomorphisms between $V$ and $W$ in its dual $\ModC{\opcat{C}}{T}$. These in turn correspond to morphisms $\phi \colon |V| \from |W|$ in $\opcat{C}$ that commute with operations: for every operation symbol $\op{i}$ of~$\theory{T}$, we have
%
\begin{equation*}
  \phi \circ \sem{\op{i}}_V = \sem{\op{i}}_W \circ \underbrace{(\phi, \ldots, \phi)}_{\arity{i}}
\end{equation*}
in the category $\opcat{C}$. If we state this in terms of $\category{C}$, we get a morphism $\phi \colon |W| \to |V|$ that commutes with cooperations: for every operation symbol $\op{i}$ of~$\theory{T}$, we have
%
\begin{equation*}
  \sem{\op{i}}_V \circ \phi = \underbrace{[\phi, \ldots, \phi]}_{\arity{i}} \circ \sem{\op{i}}_W.
\end{equation*}.

\end{document}
